import re
from typing import (
    Dict,
    List,
)
from dataclasses import dataclass, field


###############################################################################
# Notes
"""
All PTF files follow the following format with some example data populated:


    FILE_TYPE = MULTI_PHYS_TABLE;

    PART 'CAPN-SMD'
    CLASS=DISCRETE

    {=============...==}
    <title row> (examples below)
    {=============...==}
    <data row> (examples below)
    <data row>
    ...
    END_PART
    END.


Example of a title row and data row for a custom part that doesn't have an AML (Approved Manufacturer List):

    : TYPE | PACK_TYPE =PART_NUMBER | JEDEC_TYPE |ALT_SYMBOLS;
    'MECCA40' |'DEF'  (!)=  'NONE' | 'mecca2-40' |'(mecca2smt,mecca2-40c23bc)'

Example of a title row and data row for a discrete resistor with an AML:

    :VALUE | TOL | PWR | PACK_TYPE | PART_NUMBER = JEDEC_TYPE | ALT_SYMBOLS |DESCRIPTION | AML | STATUS | ORACLE_LINK | MANUFACTURER;
    '0.075' | '1%' | '0.5W' | '2010' | '605284'(!) = '2010A' | '()' | 'RESISTOR,SMR,RES,CERM,0.075,+-1%,.5W,300PPM,2010'                                   | 'LR201001R075F,LRCLR2010LF01R075FTR1K' | 'Production'  | 'https://fa-euid-saasfaprod1.fa.ocs.oraclecloud.com/fscmUI/faces/deeplink?objType=ITEMS&action=EDIT&objKey=itemId%3D100000012163040%3BorgId%3D300000007372001' | 'IRC INC,IRC INC'

///////////////////////////////////////////////////////////////////////////////
This library performs a relatively loose parse of a PTF file with strict
requirements on the expected sequence of lines as validation. Since PTF files
are generated by the Cadence tool, the above format is to be generally accepted
as the norm for an expected format.

Ruleset used for parsing:
- All empty rows can be ignored
- All rows starting with character { can be ignored as a comment line
- All rows starting with the string "END" can be ignored
- All other rows must be delimited by either = or | to split fields
- Rows must be declared in this order for it to be considered a valid file
    FILE_TYPE
    PART
    CLASS
    <title row>
    <data row>
- Comma separated groups should stay as a comma separated groups in a string
///////////////////////////////////////////////////////////////////////////////
"""


###############################################################################
FILE_TYPE_ROW = 0
PART_ROW = 1
CLASS_ROW = 2
TITLE_ROW = 3
DATA_ROW_START = 4


@dataclass
class Library:
    file_type: str = ""
    part_type: str = ""
    part_class: str = ""
    columns: list = field(default_factory=list)
    parts: list = field(default_factory=list)


###############################################################################
class PTFLib:
    # Constructor input is path to PTF file
    def __init__(self, ptf_filepath):
        self.lib = Library()
        # Populate library
        self.__ingest_library(ptf_filepath=ptf_filepath)

    def get_column_names(self) -> List[str]:
        return self.lib.columns

    def get_all_parts(self) -> List[str]:
        return self.lib.parts

    def find_part(self, column_name, part_number) -> List[Dict]:
        return self.__find_pn_in_lib(column_name=column_name, part_number=part_number)

    def get_file_type(self) -> str:
        return self.lib.file_type

    def get_part_type(self) -> str:
        return self.lib.part_type

    def get_part_class(self) -> str:
        return self.lib.part_class

    def get_part_type_from_entity(self, filepath) -> str:
        return self.__get_part_type_from_verilog_file(filepath)

    def __find_pn_in_lib(self, column_name, part_number) -> List[Dict]:
        # Cannot look for a part without a matching column name
        if column_name not in self.lib.columns:
            raise ValueError("No matching column name found")
        # Get column position
        col_pos = self.lib.columns.index(column_name)
        # Find matching parts
        parts_found = []
        for part in self.lib.parts:
            if len(part) > col_pos and part[col_pos] == part_number:
                parts_found.append(dict(zip(self.lib.columns, part)))
        return parts_found

    def __ingest_library(self, ptf_filepath):
        # Read and parse the ptf file
        with open(ptf_filepath, "r") as ptf:
            # Read lines and ignore blank/comment/end lines
            content_lines = [
                line
                for line in ptf.readlines()
                if line.strip() and not line.startswith("{") and not line.startswith("END")
            ]
        # Re-format the PART row to keep parse consistent
        if len(content_lines) >= 2:
            content_lines[PART_ROW] = content_lines[PART_ROW].replace(" ", "|")
        # Split lines by | character
        ptf_data = [line.split("|") for line in content_lines]
        # Validate PTF headers
        self.__validate_ptf_header(ptf_data)
        # Save data to library
        rgx = re.compile(r"[^-=,\w]+")
        self.lib.file_type = rgx.sub("", ptf_data[FILE_TYPE_ROW][0]).split("=")[1]
        self.lib.part_type = [rgx.sub("", f) for f in ptf_data[PART_ROW]][1]
        self.lib.part_class = rgx.sub("", ptf_data[CLASS_ROW][0]).split("=")[1]
        self.lib.columns = [
            rgx.sub("", item) for item in re.split("[=|]", content_lines[TITLE_ROW])
        ]
        for idx, data_row in enumerate(content_lines[DATA_ROW_START:]):
            part_cols = []
            for col in [d.strip() for d in data_row.split("|")]:
                if "http" in col:
                    part_cols.append(col.replace("'", "").strip())
                else:
                    for f in col.split("="):
                        stripped = re.sub(r"[^(!) ,.\w]+", "", f).strip()
                        part_cols.append(re.sub(r"[^ ,.\w]+", "", stripped))
            self.lib.parts.append(part_cols)

    def __get_part_type_from_verilog_file(self, filepath):
        part_type = ""
        with open(filepath, "r") as fp:
            lines = fp.readlines()
            for line in lines:
                if line.startswith("module"):
                    part_type = line.split()[1]
        return part_type

    def __validate_ptf_header(self, ptf_lines):
        # Cannot process an empty list
        if not ptf_lines:
            raise ValueError("No data in file")
        # Cannot process a PTF file without at least 4 rows
        if not len(ptf_lines) >= 5:
            raise ValueError("Insufficient rows in PFT file to load library")
        # Invalid PTF file if the first row doesn't start with "FILE_TYPE"
        if not (ptf_lines[0] and ptf_lines[0][0].startswith("FILE_TYPE")):
            raise ValueError("FILE_TYPE not declared at expected location")
        # Invalid PTF file if the second row doesn't start with "PART"
        if not (ptf_lines[1] and (ptf_lines[1][0]).startswith("PART")):
            raise ValueError("PART not declared at expected location")
        # Invalid PTF file if the third row doesn't start with "CLASS"
        if not (ptf_lines[2] and ptf_lines[2][0].startswith("CLASS")):
            raise ValueError("CLASS not declared at expected location")
        # Insufficient PTF file if there are no rows in the title column
        if not (ptf_lines[3]):
            raise ValueError("Title row with column names not declared at expected location")
